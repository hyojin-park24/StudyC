//변수 
// 변수 선언, 쓰레기 값, 자료형, const, 예약어, 식별자
// 변수 선언 이유 : 프로그램에서 데이터를 메모리에 저장해 놓으면 필요할 때마다 꺼내서 사용 가능 
// 변수선언을 통해 메모리에 저장 공간을 확보 

// 변수는 데이터 종류에 따라 각각 다른 형태를 사용
// 변수 데이터 사용 형태 : 정수-int, 실수-double, 문자-double, 문자열 - char
// 변수 = 데이터를 저장하는 공간! 
// int a; / int = 자료형(얘 이름은 예약어), a = 변수명(얘 이름은 식별자)
// => "정수를 저장할 공간을 a라 이름 붙여 메모리에 4바이트 할당할거야!"라고 컴파일에게 알려줌 
// 변수명 = 메모리에 붙이는 임시 주소
// 식별자의 규칙이 있어
// 1. 알파벳 대문자 A~Z, 소문자 a~z, 숫자0~9, _밑줄 로 만들기
// 2. 숫자로 시작할 수 없어
// 3. 대문자와 소문자는 서로 다른 식별자로 인식한다
// 4. 예약어는 식별자로 쓸 수 읎어

// <변수 선언과 사용>

// 변수 선언 : "변수 있당~" 알려줌 
// 변수 선언 -> 메모리에 저장 공간 생김 - 그때의 값 : 쓰레기 값
// 쓰레기 값 때문에 프로그램에 오류가 생길 수 있음
// 그래서 원하는 값으로 바꾸는 초기화 과정이 필요해! 그게 바로 대입 연산자!! 
// 대입 연산자 : a = 10; : 오른쪽 값(10)을 왼쪽 a에 저장한다!

// <자료형 = 데이터형>
// 자료형 : 정수형 / 실수형 
// 변수는 저장 공간이니, 저장되는 데이터 형태에 따라 다양한 형태로 사용됨

// 정수형 : 메모리 저장 크기에 따라 int, char, short, long, longlong 
// 당연히 크기가 큰 자료형이 더 많은 범위의 값을 저장할 수 있어
// 그 중 char형 변수를 사용하면 문자를 가장 효과적으로 저장할 수 있어
// 왜냐하면 아스키 값으로 바꾸어 처리하면 char형이 작은 범위의 정수를 저장할 수 있거든 

// 실수형 : 메모리 저장 크기에 따라 float, double, long double
// 실수 자료형은 값의 범위보다 유효 숫자의 개수에 주목!
// 유효 숫자가 많을수록 더 정확한 값을 표현할 수 있어

// 정수형을 기본으로 사용하되 실수형은 꼭 필요한 경우만 사용
// 실수형은 유효 숫자가 많은 double형을 기본으로 사용! 

// < 문자열 저장 >
// 프로그램 작성 중 숫자 뿐만아닌 문자열을 변수에 담아야 함
// 이때 문자열 => char형의 배열 형태로 만들어 저장!! 
// char 배열명 [문자열길이+1] = 문자열;
// Ex) char fruit(배열명) [6](문자열 길이 +1) = "apple"(문자열);
// 그런데 [문자열 길이 +1] 여기서 +1을 하는 이유는, 널문자를 자동 추가하기 때문!!
// 컴파일러가 문자열 끝에 '\0'널문자를 자동으로 추가하는 특징이 있어

// 기본 자료형을 여러개 묶어 사용하는 것 = 배열 (=첫번 째 주소 값)
// 즉, 배열 이름(첫번째 주소)는 상수이므로 대입연산자 불가능!!
// 왜냐하면 상수는 값이 변하면 안되는 형태이기 때문!!!!!!!!!!!
// char배열은 문자열을 저장하는 변수의 역할을 하며 %s로만 출력함!

// <strcpy 함수>
// char 배열에 초기화 이외에 문자열을 저장할 때 strcpy함수 사용!
// 소스코드에 string.h 헤더 파일 포함해야함 
// string.h 에는 strcpy가 정의 되어 있음 
// strcpy = string copy

// <const를 사용한 변수> 
// 변수를 상수화 시킬 때 사용하는 const (변수 예외)
// 주의 !! 반드시 선언 동시에 초기화 시켜줘야 합니다요~! 
// 초기화 하지 않으면 변수의 쓰레기 값이 계속 사용되고, 컴파일 과정에서 에러납니다~!!!
// const 자료형 변수명 = 값; 형태
// 점점 정신이 나가고 있어요~~~~ ㅋ;

//#define _CRT_SECURE_NO_WARNINGS
//#include <stdio.h>		// 지금부터의 내용을 프로그램에 복사할게~
//#include <string.h>		// 나 문자열 복사 할거야!(초기화 값 외에 추가할거야!)
//
//int main()				// 메인 함수 호출한다~
//{
//	// 변수 선언 
//	int a;				// 나 정수형 a라는 변수 선언 한다!
//	int b, c;			// 나 정수형 b,c라는 변수 선언 한다!
//	// 그런데 이렇게 변수의 자료형이 같으면 동시에 둘 이상의 변수 선언 쌉가능~
//	// Ex) int a,b,c; 이렇게 가능!
//	double da;			// 나 실수형 da라는 변수 선언 한다!
//	char ch;			// 나 문자형 ch라는 변수 선언 한다!
//	
//	// 그리고 지금까지는 쓰레기 값이 들어가 있으니깐 변수들 초기화 시켜줄거야!
//	// 왜냐면 쓰레기 값 때문에 프로그램에 오류가 생길 수 있거든 
//	// 이제 대입 연산자 써서 초기화 한다~
//	
//	// 선언 동시에 초기화
//	char ch1 = 'A';		
//	// 나 문자형 ch1라는 변수를 선언하고 A를 저장 공간에 대입해서 저장한다!
//	// 그런데 ch1에는 65라는 아스키 코드 값이 저장 되어 있어.
//	// 왜냐하면 문자 'A'의 아스키 코드 값이 65이기 때문이지 
//	char ch2 = 65;		
//	// 나 문자형 ch2라는 변수를 선언하고 65를 ch2라는 저장공간에 저장한다!
//	// 결국 다른 방식으로 초기화 했지만 같은 값이 저장되는 거야!
//	// 값을 문자로 출력 하느냐, 값으로 출력 받느냐 변환 문자 결정 차이라는 것!
//
//	float ft = 1.23456789;
//	double db = 1.23456789;
//	// 나 실수형 ft라는 변수를 선언하고 1.23456789를 ft라는 저장공간에 저장하고 초기화 한거야!
//
//	char fruit[20] = "strawberry"; 
//	// 나 문자형 fruit이라는 배열을 선언할거야, 길이(방 개수)는 20이고, strawberry를 fruit[20]에 저장하고 초기화 한거야! 
//
//	char fruit1[20] = "banana";
//	// 나 문자형 fruit1이라는 배열을 선언하고, 방개수는 20개 이고, banana를 fruit1[20]에 저장하고 초기화 했어!
//	
//	int income = 0;
//	// 소득액 초기화
//	// 나 정수형 income이라는 변수를 선언하고 0을 income에 저장하고 초기화 했어!
//	double tax;
//	// 세금
//	// 나 실수형 tax라는 변수를 선언했어!
//	const double tax_rate = 0.12;
//	// 세율 초기화
//	// 나 실수형 tax_rate라는 변수를 선언하고 0.12를 tax_rate에 저장하고 초기화 했어! 
//	// 그리고 const를 실행해서 상수화 시킬거야!(변하지 않는 값으로 바꿀거야!)
//
//	// 변수 값 대입
//	a = 10;				// 10을 a저장 공간에 저장할거야
//	b = a;				// a의 값을 b저장 공간에 저장할거야
//	c = a + 20;			// a의 값에 20을 더한 값을 c저장 공간에 저장할거야
//	da = 3.5;			// 3.5를 da저장 공간에 저장할거야
//	ch = 'A';			// A를 ch저장 공간에 저장할거야
//
//	income = 456;
//	// 소득액 저장 
//	// 456을 정수형 income 저장공간에 저장할거야! 
//	tax = income * tax_rate;
//	// 세금 계산 
//	// income 값과 tax_rate에 저장된 값을 곱한 값을 tax저장 공간에 저장할거야!
//
//	// 이제 저장한 값을 printf함수로 호출할거야~
//	// 그러면 운영체제가 할당 받아서 메모리에 할당해서 출력해줄거야~
//
//	printf("변수 a의 값 : %d\n", a);
//	// 그런데 수를 출력할 변환 문자 필요해서 %d 변환문자 쓸거고 변환문자에는 a의 값이 오게끔 할거야
//	printf("변수 b의 값 : %d\n", b);
//	// 마찬가지로 변환문자 %d를통해 b 값을 출력할거야~
//	printf("변수 c의 값 : %d\n", c);
//	// 왜냐하면 앞에 대입연산자를 통해 데이터값을 각 주소에 저장해뒀거든
//	printf("변수 da의 값 : %.1lf\n", da);
//	// 실수니깐 변환 문자 %lf사용할거고 da값을 받을거야~ 
//	// 변수를 선언할 때 실수형 변수 자료형은 double,
//	// 변수 값을 출력할 때 사용하는 실수형 변환 문자는 %lf 
//	printf("변수 ch의 값 : %c \n", ch);
//	// 문자니깐 변환 문자 %c 사용할거고 ch값을 받을거야
//	// 문자를 선언 할 때 변수 자료형은 char,
//	// 변수 값을 출력할 때 사용하는 문자형 변환 문자는 %c Okay?
//
//	printf("문자 %c의 아스키 코드 값 : %d\n", ch1, ch1);
//	// ch1의 문자값을 %c 변환 문자를 통해 출력할 거고, 
//	// ch1의 정수 값을 %d 변환 문자를 통해 출력할 거야
//	// printf함수를 통해서! 
//
//	printf("아스키 코드 값이 %d인 문자 : %c\n", ch2, ch2);
//	// 결국 같은 값이 저장되는데 이 값을 문자로 출력하느냐, 값으로 출력하느냐
//	// 변환 문자의 결정에 따라 다르다는 것!
//
//	printf("float형 변수의 값 : %.20f\n", ft);
//	printf("double형 변수의 값 : %.20f\n", db);
//	// 같은 값을 초기화 시켰는데 출력값이 다른 이유는,
//	// 컴퓨터에서 실수를 표현하는 방식이 오차를 갖고 있기 때문이야 
//	// 따라서 자료형에 따라 유효숫자 범위 내에서 사용해야해
//	// float형 유효 숫자 7자리, double형은 15자리 내의 값을 사용하는 것이지! 
//
//	printf("딸기 : %s\n", fruit);
//	// fruit에 저장된 strawberry를 문자열 %s 변환 문자를 사용해 printf함수로 출력할거야 
//	printf("딸기쨈 : %s %s\n", fruit, "jam");
//	// 문자열 상수를 직접 %s로 출력? ???? ????? 모르겠당..
//
//	printf("%s\n", fruit1);
//	// fruit1에 초기화된 값 banana를 변환문자 %s를 통해 printf함수로 출력할거야
//	strcpy(fruit1, "apple");
//	// 근데 apple도 같이 출력하고 싶어서 strcpy함수를 통해 fruit1에 apple값을 추가했어!
//	printf("%s\n", fruit1);
//	// 그랬더니 banana와 apple이 같이 printf함수를 통해 출력 됐어!! 
//
//	printf("세금은 : %.1lf입니다. \n", tax);
//	// 위에서 계산한 tax값을 %lf 변환 문자를 통해 printf 함수로 출력할거야
//	// 그런데 만약에 tax_rate의 값을 바꾸는 문장 <tax_rate = 0.15>를 추가하면 에러남!
//	// 그것이 const의 위력!
//	// const를 사용하면 복잡한 값을 의미 있는 이름으로 쉽게 쓸 수 있고 값이 바뀌지 않음을 보장 쌉가능!
//
//	return 0;			// 함수 끝나면 종료한다~
//}

// 변수와 상수의 출력 차이점 
// 상수는 변수와 달리 printf로 바로 출력 가능
// 변수는 상수와 달리 변환 형태 지정 조건이 많기때문에 
// 메모리에 저장공간을 확보하고(선언), 대입 연산자를 통해 초기화 해야하고(변환 문자를 사용해 데이터 입력)
// 또는 초기화 하지 않은 값을 사용자가 지정할 때에 scanf함수를 이용해 값 입력 해주고
// pritf함수를 통해 출력해줘야 함! 